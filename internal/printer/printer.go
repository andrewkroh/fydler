// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Package printer provides functions to print diagnostics in different formats.
package printer

import (
	"cmp"
	"encoding/json"
	"fmt"
	"html"
	"io"
	"os"
	"slices"
	"strings"
	"time"

	"github.com/fatih/color"

	"github.com/andrewkroh/fydler/internal/analysis"
)

func JSON(diags []analysis.Diagnostic, w io.Writer) error {
	type Report struct {
		Diags []analysis.Diagnostic `json:"diagnostics"`
		Time  string                `json:"timestamp"`
		Args  []string              `json:"args,omitempty"`
	}

	r := Report{
		Diags: diags,
		Time:  time.Now().Format(time.RFC3339),
	}

	enc := json.NewEncoder(w)
	enc.SetIndent("", "  ")
	enc.SetEscapeHTML(false)
	return enc.Encode(r)
}

func Text(diags []analysis.Diagnostic, w io.Writer) error {
	return text(diags, w, false)
}

func ColorText(diags []analysis.Diagnostic, w io.Writer) error {
	return text(diags, w, true)
}

func text(diags []analysis.Diagnostic, w io.Writer, wantColor bool) error {
	red := color.New(color.FgRed)
	bold := color.New(color.Bold)
	if !wantColor {
		red.DisableColor()
		bold.DisableColor()
	}

	var err error
	for _, d := range diags {
		if _, err = bold.Fprint(w, d.Pos); err != nil {
			return err
		}
		if _, err = red.Fprint(w, " ", d.Message); err != nil {
			return err
		}
		if _, err = fmt.Fprintf(w, " (%s)\n", d.Category); err != nil {
			return err
		}

		for _, r := range d.Related {
			if _, err = bold.Fprintf(w, "  %s", r.Pos); err != nil {
				return err
			}
			if _, err = fmt.Fprintf(w, " %s (%s)\n", r.Message, d.Category); err != nil {
				return err
			}
		}
	}
	return nil
}

func Markdown(diags []analysis.Diagnostic, w io.Writer, analyzers []*analysis.Analyzer, version string) error {
	// These are set by GitHub Actions.
	repo := os.Getenv("GITHUB_REPOSITORY")
	if repo == "" {
		repo = "elastic/integrations"
	}
	commit := os.Getenv("GITHUB_SHA")
	if commit == "" {
		commit = "main"
	}

	toURL := func(p analysis.Pos) string {
		return fmt.Sprintf("https://github.com/%s/blob/%s/%s#L%d", repo, commit, p.File, p.Line)
	}

	// Sort diagnostics by category, file, and line.
	slices.SortFunc(diags, func(a, b analysis.Diagnostic) int {
		if c := cmp.Compare(a.Category, b.Category); c != 0 {
			return c
		}
		if c := cmp.Compare(a.Pos.File, b.Pos.File); c != 0 {
			return c
		}
		return cmp.Compare(a.Pos.Line, b.Pos.Line)
	})

	var category string
	for _, d := range diags {
		if category != d.Category {
			category = d.Category
			fmt.Fprintf(w, "## %s\n\n", d.Category)
			for _, a := range analyzers {
				if a.Name == d.Category {
					fmt.Fprintf(w, "%s\n\n", a.Description)
					break
				}
			}
		}

		fmt.Fprintf(w, "- [%s:%d](%s) %s\n", d.Pos.File, d.Pos.Line, toURL(d.Pos), escapeMarkdown(d.Message))

		for _, r := range d.Related {
			fmt.Fprintf(w, "  - [%s:%d](%s) %s\n", r.Pos.File, r.Pos.Line, toURL(r.Pos), escapeMarkdown(r.Message))
		}
		fmt.Println()
	}

	fmt.Println("--------")
	fmt.Printf("Generated by [fydler](https://github.com/andrewkroh/fydler) %s\n", version)

	return nil
}

// githubMarkdownEscapes is a replacer for characters that have special meaning
// in GitHub flavored markdown.
var githubMarkdownEscapes = strings.NewReplacer(
	// Prevent GitHub from interpreting @ as a user mention.
	"@", "<span>@</span>",
)

// escapeMarkdown escapes characters that have special meaning in HTML and
// GitHub flavored markdown.
func escapeMarkdown(s string) string {
	return githubMarkdownEscapes.Replace(html.EscapeString(s))
}
